package manager_crud_controller

import (
	"fmt"

	"github.com/RydKrm/golang_API_build/database"
	"github.com/RydKrm/golang_API_build/models"
	"github.com/RydKrm/golang_API_build/utils"
	"github.com/RydKrm/golang_API_build/utils/response"
	"github.com/gin-gonic/gin"
	"golang.org/x/crypto/bcrypt"
)

func ManagerRegister(c *gin.Context){
	var manager models.Manager

	if err := c.ShouldBindJSON(&manager); err!=nil{
		response.NegativeResponse(c, "Name, Emil, Phone number field required");
		return ;
	}

	var count int64;
	countManager := database.DB.Model(&models.Manager{}).Where("email = ? OR phone_number = ?",manager.Email, manager.PhoneNumber).Count(&count);

	if countManager.Error != nil{
		response.NegativeResponse(c, "Error checking with Manager database");
		return;
	}

	if count > 0 {
		response.NegativeResponse(c, "Manager already exists with email or phone number")
		return;
	}
	// fmt.Printf("\n \n Manager body %v", Manager)

	password := utils.AutoGeneratedPassword()
	fmt.Printf("manager Password %v", password);
	manager.Password = password;

	createManager := database.DB.Create(&manager);
	if createManager.Error != nil {
		response.NegativeResponse(c, "Field to create Manager")
		return;
	}

	response.PositiveResponse(c, "Manager Created", gin.H{"Manager":manager})
}

func ManagerLogin(c *gin.Context){
	var request struct {
		Email string `json:"email"`
		Password string `json:"password"`
	}

	if err:= c.ShouldBindJSON(&request); err != nil{
		response.NegativeResponse(c, "Email and password required");
		return;
	}

	var manager models.Manager;

	if err := database.DB.Where("email = ?",request.Email).First(&manager).Error; err!=nil{
		response.NegativeResponse(c, "Could not find Manager with this email")
		return
	}

	checkPassword := bcrypt.CompareHashAndPassword([]byte(manager.Password),[]byte(request.Password));

	if checkPassword != nil {
		response.NegativeResponse(c, "Password mismatch")
		return;
	}

	token, err := manager.GenerateToken();

	if err!= nil {
		response.NegativeResponse(c, "Error to generaate token")
		return;
	}

	response.PositiveResponse(c, "Logedin Successfully", 
	gin.H{
		"manager":manager,
		"token" : token,
	})
}

func GetSingleManager(c *gin.Context){
	id := c.Param("id");

	var manager models.Manager;

	find := database.DB.First(&manager, id);

	if find.Error != nil {
		response.NegativeResponse(c, "Manager not found by id");
		return;
	}

	response.PositiveResponse(c, "Manager found", gin.H{"manager": manager})
}

func GetAllManager(c *gin.Context){
	var managerList [] models.Manager;

	find := database.DB.Find(&managerList);

	if find.Error != nil {
		response.NegativeResponse(c, "Error in fetching Manager list")
		return;
	}
	response.PositiveResponse(c, "Manager list", gin.H{"ManagerList":managerList})
}

func ManagerUpdateProfile(c *gin.Context) {
    managerID := c.Param("id")

    var manager models.Manager

    // Load the Manager by ID first to ensure it exists
    if err := database.DB.First(&manager, managerID).Error; err != nil {
        response.NegativeResponse(c, "Manager not found")
        return
    }

    var updateData map[string]interface{}

    if err := c.ShouldBindJSON(&updateData); err != nil {
        response.NegativeResponse(c, "Invalid request payload")
        return
    }

    // Apply the update using the `Updates` method
    if err := database.DB.Model(&manager).Where("id = ?", managerID).Updates(updateData).Error; err != nil {
        response.NegativeResponse(c, "Failed to update Manager")
        return
    }

    // Respond with the updated Manager profile
    response.PositiveResponse(c, "Manager profile updated successfully", gin.H{"manager": manager})
}

func ManagerUpdatePassword(c *gin.Context){
	var dataList struct {
		OldPassword string `json:"oldPassword"`
		NewPassword string `json:"newPassword"`
	}
	
	if err:= c.ShouldBindJSON(&dataList); err!=nil{
		response.NegativeResponse(c, "New and Old password required")
		return;
	}

	managerId := c.Param("id");

	var manager models.Manager;

	if err := database.DB.First(&manager,managerId).Error; err!= nil {
		response.NegativeResponse(c,"Manager not found by Id")
		return;
	}

	if err := bcrypt.CompareHashAndPassword([]byte(manager.Password),[]byte(dataList.OldPassword)); err != nil {
		response.NegativeResponse(c, "Old password did not matched")
		return;
	}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(dataList.NewPassword), bcrypt.DefaultCost)
	if err != nil {
		response.NegativeResponse(c, "Error to hashed the password")
		return
	}

	manager.Password = string(hashedPassword)

	if err := database.DB.Save(&manager).Error; err != nil {
		response.NegativeResponse(c, "Failed to update the password")
		return
	}

	response.PositiveResponse(c, "Password updated")
}

func ManagerUpdateStatus(c *gin.Context){

	managerId := c.Param("id");

	var manager models.Manager;

	if err:= database.DB.First(&manager, managerId).Error; err!=nil{
		response.NegativeResponse(c, "Manager not found by id")
		return;
	}

	manager.Status = !manager.Status;

	if err := database.DB.Save(&manager).Error; err != nil {
		response.NegativeResponse(c, "Status not updated");
		return;
	}

	response.PositiveResponse(c, "Manager status updated");
}

