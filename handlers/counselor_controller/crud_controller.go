package counselor_crud_controller

import (
	"github.com/RydKrm/golang_API_build/database"
	"github.com/RydKrm/golang_API_build/models"
	"github.com/RydKrm/golang_API_build/utils"
	"github.com/RydKrm/golang_API_build/utils/response"
	"github.com/gin-gonic/gin"
	"golang.org/x/crypto/bcrypt"
)

func CounselorRegister(c *gin.Context){
	var counselor models.Counselor

	if err := c.ShouldBindJSON(&counselor); err!=nil{
		response.NegativeResponse(c, "Name, Emil, Phone number field required");
		return ;
	}

	var count int64;
	countCounselor := database.DB.Model(&models.Counselor{}).Where("email = ? OR phone_number = ?",counselor.Email, counselor.PhoneNumber).Count(&count);

	if countCounselor.Error != nil{
		response.NegativeResponse(c, "Error checking with counselor database");
		return;
	}

	if count > 0 {
		response.NegativeResponse(c, "Counselor already exists with email or phone number")
		return;
	}

	counselor.CompanyID = 1;

	// fmt.Printf("\n \n counselor body %v", counselor)

	password := utils.AutoGeneratedPassword()
	counselor.Password = password;

	createCounselor := database.DB.Create(&counselor);
	if createCounselor.Error != nil {
		response.NegativeResponse(c, "Field to create counselor")
		return;
	}

	response.PositiveResponse(c, "Counselor Created", gin.H{"counselor":counselor})
}

func CounselorLogin(c *gin.Context){
	var request struct {
		Email string `json:"email"`
		Password string `json:"password"`
	}

	if err:= c.ShouldBindJSON(&request); err != nil{
		response.NegativeResponse(c, "Email and password required");
		return;
	}

	var counselor models.Counselor;

	if err := database.DB.Model(&models.Counselor{}).Where("email = ?",request.Email).Scan(counselor); err!=nil{
		response.NegativeResponse(c, "Could not find counselor with this email")
		return
	}

	checkPassword := bcrypt.CompareHashAndPassword([]byte(counselor.Password),[]byte(request.Password));

	if checkPassword != nil {
		response.NegativeResponse(c, "Password mismatch")
		return;
	}

	token, err := counselor.GenerateToken();

	if err!= nil {
		response.NegativeResponse(c, "Error to generaate token")
		return;
	}

	response.PositiveResponse(c, "Logedin Successfully", 
	gin.H{
		"counselor":counselor,
		"token" : token,
	})
}

func GetSingleCounselor(c *gin.Context){
	id := c.Param("id");

	var counselor models.Counselor;

	find := database.DB.First(&counselor, id);

	if find.Error != nil {
		response.NegativeResponse(c, "Counselor not found by id");
		return;
	}

	response.PositiveResponse(c, "Counselor found", gin.H{"counselor": counselor})
}

func GetAllCounselor(c *gin.Context){
	var counselorList [] models.Counselor;

	find := database.DB.Find(&counselorList);

	if find.Error != nil {
		response.NegativeResponse(c, "Error in fetching counselor list")
		return;
	}
	response.PositiveResponse(c, "Counselor list", gin.H{"counselorList":counselorList})
}

func CounselorUpdateProfile(c *gin.Context) {
    counselorID := c.Param("id")

    var counselor models.Counselor

    // Load the counselor by ID first to ensure it exists
    if err := database.DB.First(&counselor, counselorID).Error; err != nil {
        response.NegativeResponse(c, "Counselor not found")
        return
    }

    var updateData map[string]interface{}

    if err := c.ShouldBindJSON(&updateData); err != nil {
        response.NegativeResponse(c, "Invalid request payload")
        return
    }

    // Apply the update using the `Updates` method
    if err := database.DB.Model(&counselor).Where("id = ?", counselorID).Updates(updateData).Error; err != nil {
        response.NegativeResponse(c, "Failed to update counselor")
        return
    }

    // Respond with the updated counselor profile
    response.PositiveResponse(c, "Counselor profile updated successfully", gin.H{"counselor": counselor})
}

func CounselorUpdatePassword(c *gin.Context){
	var dataList struct {
		OldPassword string `json:"oldPassword"`
		NewPassword string `json:"newPassword"`
	}
	
	if err:= c.ShouldBindJSON(&dataList); err!=nil{
		response.NegativeResponse(c, "New and Old password required")
		return;
	}

	counselorId := c.Param("id");

	var counselor models.Counselor;

	if err := database.DB.First(&counselor,counselorId).Error; err!= nil {
		response.NegativeResponse(c,"Counselor not found by Id")
		return;
	}

	if err := bcrypt.CompareHashAndPassword([]byte(counselor.Password),[]byte(dataList.OldPassword)); err != nil {
		response.NegativeResponse(c, "Old password did not matched")
		return;
	}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(dataList.NewPassword), bcrypt.DefaultCost)
	if err != nil {
		response.NegativeResponse(c, "Error to hashed the password")
		return
	}

	counselor.Password = string(hashedPassword)

	if err := database.DB.Save(&counselor).Error; err != nil {
		response.NegativeResponse(c, "Failed to update the password")
		return
	}

	response.PositiveResponse(c, "Password updated")
}

func CounselorUpdateStatus(c *gin.Context){

	counselorId := c.Param("id");

	var counselor models.Counselor;

	if err:= database.DB.First(&counselor, counselorId).Error; err!=nil{
		response.NegativeResponse(c, "Counselor not found by id")
		return;
	}

	counselor.Status = !counselor.Status;

	if err := database.DB.Save(&counselor).Error; err != nil {
		response.NegativeResponse(c, "Status not updated");
		return;
	}

	response.PositiveResponse(c, "Counselor status updated");
}

func CounselorUpdateTeamLead(c *gin.Context){
	counselorId := c.Param("id");

	var counselor models.Counselor;

	if err:= database.DB.First(&counselor, counselorId).Error; err!=nil{
		response.NegativeResponse(c, "Counselor not found by id")
		return;
	}

	counselor.TeamLead = !counselor.TeamLead;

	if err := database.DB.Save(&counselor).Error; err != nil {
		response.NegativeResponse(c, "Counselor team lead status not updated");
		return;
	}

	response.PositiveResponse(c, "Counselor team lead field updated");
}